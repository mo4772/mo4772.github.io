---
layout:     post
title:      SR和RR包的接收及发送
subtitle:   RTCP协议 SR和RR包的接收及发送
date:       2025-12-10
author:     mo4772
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Webrtc
    - RTCP
---


webrtc中处理rtp和rtcp包的业务逻辑都在rtp_rtcp模块中，这篇文章介绍的是处理rtcp SR和RR包的逻辑，包括接收，解析，发送。SR和RR是rtcp中最重要的包，通过它们可以计算rtt，抖动，丢包率，进行音视频同步。



先看看rtp_rtcp模块中处理rtcp模块的整体结构图，如下：



![](https://github.com/mo4772/mo4772.github.io/raw/master/pic/RtpRtcpInterface_lt.png)

相关模块包括`ModuleRtcpImpl2`，`RTCPSender`，`RTCPReceiver`，"总管家"是`ModuleRtcpImpl2`。



`RtpRtcpInterface`定义了rtp_rtcp模块的所有接口，包括rtcp和rtp，图中只列出了与rtcp相关的接口。`ModuleRtpRtcpImp2`是它的实现类，它包含了`RTCPSender`用于发送Rtcp包，`RTCPReceiver`用于接收Rtcp包。



### 接收RTCP包
当只是接收媒体流时(only receive)，只会收到SR包，当既发送媒体流又接收媒体流时(sendrecv)，则SR和RR包都会收到。统一的入口是`ModuleRtcpImpl2::IncomingRtcpPacket`，随后会调用`RTCPReceiver::IncomingPacket`，解析和处理RTCP包的逻辑在`RtcpReceiver`中。

![](https://github.com/mo4772/mo4772.github.io/raw/master/pic/js_sr_rr.png)



rtcp包通过`RTCPReceiver::IncomingPacket`传入后，会判断时SR还是RR包，再分别调用对应的处理函数。

SR包中发送者的信息会存储起来，SR和RR包的核心都是`ReportBlock`，所以都会进入`RtcpReceiver::HandleReportBlock`函数中解析`ReportBlock`，通过`ReportBlock`中的字段值来计算RTT，所有计算的RTT值都会存储起来。



上面的图也反映了`RTCPRecevier`的核心作用及所存储的信息。



### 发送SR/RR
发送SR和RR包的逻辑都在`RTCPSender`中。SR和RR是周期性的发送，在RFC3550中要求RTCP的发送周期是动态生成，每次发送RTCP包后，需要计算下次发送的时间点。

在每次调用`RTCPSender::SendRTCP`时，都会附加上SR或RR包并且会计算下次发送SR/RR的时间。

### compound packet
在webrtc中rtcp包都是被封装成了compound packet包，就是将多个rtcp包封装成一个大的包发送，包的组成是将多个rtcp包叠加。



在RFC3550中，一个compound packet中至少要包含SR或RR包，要包含SDES包。在webrtc中，有两种模式，一种是`kCompound`就是compound packet，是属于RFC3550的标准。一种是`kReducedSize`是RFC5506的标准，该模式下不必与SR，RR，SDES包一起发送。



但是的在解析compound packet时，webrtc并没有规则限制，不管有没有SR，SR，SDES包，都会正常解析。

#### compound packet的生成
组装compound packet需要通过`RTCPSender`中的 `report_flags_`来控制，当调用`RTCPSender::SendRTCP`时，并不意味着需马上产生对应的rtcp包，而是将这个请求缓存在`report_flags_`中，在满足了compound packet和rtcp时间间隔要求后再生成。



`report_flags_`为`set`类型，`std::set<ReportFlag> report_flags_`。

```cpp
struct ReportFlag {
    ReportFlag(uint32_t type, bool is_volatile)
        : type(type), is_volatile(is_volatile) {}
    bool operator<(const ReportFlag& flag) const { return type < flag.type; }
    bool operator==(const ReportFlag& flag) const { return type == flag.type; }
    const uint32_t type;
    const bool is_volatile;
}

```



`**ReportFlag**`**包含两个成员变量，**`**type**`**表示rtcp包的类型，**`**is_volatile**`**(单词volatilte的意思是易变的)是一个控制变量，当它为false时，表示每次发送的compound packet中都会包含这个rtcp包。**



控制rtcp生成有三个方法：

+ `SetFlag(uint32_t type,bool is_volatile)`

```cpp
void RTCPSender::SetFlag(uint32_t type, bool is_volatile) {
  if (type & kRtcpAnyExtendedReports) {
    report_flags_.insert(ReportFlag(kRtcpAnyExtendedReports, is_volatile));
  } else {
    report_flags_.insert(ReportFlag(type, is_volatile));
  }
}
```

`SetFlag`缓存对应rtcp的请求(在`report_flags_`中添加一个元素)

+ `IsFlagPresent(uint32_t type)`

```cpp
bool RTCPSender::IsFlagPresent(uint32_t type) const {
  return report_flags_.find(ReportFlag(type, false)) != report_flags_.end();
}
```

`IsFlagPresent`判断是否有缓存对应的rtcp类型的请求

+ `ConsumeFlag(uint32_t type,bool forced = false)`

```cpp
bool RTCPSender::ConsumeFlag(uint32_t type, bool forced) {
  auto it = report_flags_.find(ReportFlag(type, false));
  if (it == report_flags_.end())
    return false;
  if (it->is_volatile || forced)
    report_flags_.erase((it));
  return true;
}
```

`ConsumeFlag`删除对应的rtcp类型的请求。



生成compound packet至少需要有SR或RR，这个逻辑在`RTCPSender`的`PrepareReport`方法中，其中会判断是否缓存SR或RR请求，没有则设置，如下代码：

```cpp
void RTCPSender::PrepareReport(const FeedbackState& feedback_state) {
    bool generate_report;
    if (IsFlagPresent(kRtcpSr) || IsFlagPresent(kRtcpRr)) {
        generate_report = true;
        RTC_DCHECK(ConsumeFlag(kRtcpReport) == false);
    } else {
        generate_report = (ConsumeFlag(kRtcpReport) && method_ == RtcpMode::kReducedSize) ||
        method_ == RtcpMode::kCompound;

        if (generate_report)
            SetFlag(sending_ ? kRtcpSr : kRtcpRr, true);
    }

    if (IsFlagPresent(kRtcpSr) || (IsFlagPresent(kRtcpRr) && !cname_.empty()))
        SetFlag(kRtcpSdes, true);

    if (generate_report) {
        ...
    }
}
```



在`RTCPSender`中的`ComputeCompoundRTCPPacket`中会根据`report_flag_`最终缓存的rtcp包类型来生成rtcp，如下：

```cpp
absl::optional<int32_t> RTCPSender::ComputeCompoundRTCPPacket(const FeedbackState& feedback_state,
                                                              RTCPPacketType packet_type,
                                                              int32_t nack_size,
                                                              const uint16_t* nack_list,
                                                              PacketSender& sender)
{
    ...
    auto it = report_flags_.begin();
    while(it != report_flags_.end()) {
    uint32_t rtcp_packet_type = it->type;
    
    if (it->is_volatile) {
      report_flags_.erase(it++);
    } else {
      ++it;
    }

    ...
    auto builder_it = builders_.find(rtcp_packet_type);.
    if (builder_it == builders_.end()) {
      RTC_NOTREACHED() << "Could not find builder for packet type "
                       << rtcp_packet_type;
    } else {
      BuilderFunc func = builder_it->second;
      (this->*func)(context, sender);
    }

    ...
    RTC_DCHECK(AllVolatileFlagsConsumed());
    return absl::nullopt;
}
```

可以看到`is_volatile`如果为false，那么对应的元素不会被删除，则每次生成rtcp包时都会有这个类型的rtcp包。



### 发送SR和RR包
SR和RR包的发送有两个入口：

+ 在需要发送rtcp包时，会调用`ModuleRtpRtcpImpl2::SendRTCP`，它会调用`RTCPSender::SendRTCP`。
+ 在每次发送 **音视频帧**时，会调用`ModuleRtpRtcpImpl2::OnSendingRtpFrame`的方法，这个方法也会调用`RTCPSender::SendRTCP`。



两个接口最终都会调用`RTCPSender`的`ComputeCompoundRTCPPacket`方法，而产生SR/RR包，一起打包成compound rtcp包发送。


#### SR和RR的发送间隔 
SR和RR是周期性的发送，在RFC3550中要求RTCP的发送周期是动态生成，每次发送RTCP包后，需要计算下次发送的时间点。虽然SR和RR包比较小，但是媒体流路数多，占用的带宽就会大，可能影响媒体流的传输，**所以RFC3550中的周期计算的算法是基于媒体流路数和媒体流量。**



`RTCPSender::SendRTCP`会调用`ComputeCompoudRTCPPacket`方法，其中会调用`PrepareReport`方法，它会计算下次发送rtcp包的时间，如下代码：

```cpp
void RTCPSender::PrepareReport(const FeedbackState& feedback_state) {
    ....
    if (generate_report) {
        ....
        // generate next time to send an RTCP report
        TimeDelta min_interval = report_interval_;

        if (!audio_ && sending_) {
          // Calculate bandwidth for video; 360 / send bandwidth in kbit/s.
          int send_bitrate_kbit = feedback_state.send_bitrate / 1000;
          if (send_bitrate_kbit != 0) {
            min_interval = std::min(TimeDelta::Millis(360000 / send_bitrate_kbit),
                                report_interval_);
          }
        
        }

        // The interval between RTCP packets is varied randomly over the
        // range [1/2,3/2] times the calculated interval.
        int min_interval_int = rtc::dchecked_cast<int>(min_interval.ms());
        TimeDelta time_to_next = TimeDelta::Millis(random_.Rand(min_interval_int * 1 / 2, min_interval_int * 3 / 2));

        RTC_DCHECK(!time_to_next.IsZero());
        SetNextRtcpSendEvaluationDuration(time_to_next);
        ....
}
```



但是在webrtc中并没有按照RFC3550去通过RTCP的流量和媒体流路数去计算，而是采用RFC3550中的三点建议：

1. 对音频是周期固定为5秒。
2. 对视频，如果是发送者，则周期值计算公式是：**360除以会话带宽（以千位/秒为单位）。对于大于72 kb/s的带宽，此最小值小于5秒。**
3. **RTCP数据包之间的间隔在计算间隔的[0.5,1.5]倍范围内随机变化，以避免所有的媒体流的RTCP包都在同一时间发送**，最终周期值需要乘以这个随机数。

以上三点在上面代码中有体现。


#### 发送RTCP包的流程图
下面是`RTCP:SendRTCP`函数的逻辑，一个是会产生SR/RR，打包成compound rtcp包发送，一个是计算下次发送SR/RR包的时间。


![](https://github.com/mo4772/mo4772.github.io/raw/master/pic/fs_rtcp.png)



















#### 






