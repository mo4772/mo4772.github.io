---
layout:     post
title:      Webrtc FEC分析(一）FEC的原理及处理流程
subtitle:   Webrtc FEC
date:       2025-09-01
author:     mo4772
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - Webrtc
    - FEC
---

## fec的基本原理
fec全称Forward Error Correction，前向纠错，就是在发送端加入纠错编码，接收端可通过编码直接纠正传输中出现的错误，无需请求重传。



在webrtc中fec是对媒体数据(视频数据)进行冗余，生成冗余数据的方法是通过**异或运算**。



对多个媒体包(两个或多个)的数据进行异或运算，产生一个数据包，它就是冗余包，随媒体包一起发送到接收端，如果参与异或的任一媒体包丢失，可以通过它与剩余的媒体包作异或运算而恢复丢失的媒体包。



**真正生成冗余数据和恢复原始数据的核心算法是异或运算**，当然可以使用其他的算法，比如Reed - Solomon 算法。在webrc中，使用的是异或运算。



![](https://github.com/mo4772/mo4772.github.io/raw/master/pic/fec/yhcz.jpg)

Data1与Data2做异或，产生数据包R，当Data1或Data2其中一个包丢失时，通过与包R做异或来恢复。



![](https://github.com/mo4772/mo4772.github.io/raw/master/pic/fec/sgfec.jpg)



上图所示，横向来看，3个包分别做异或操作，得到冗余包R1，R2，R3。当丢失一个包时，可以通过冗余包与另外两个包恢复。



但是丢失两个包时，如图中第二项，就无法恢复了。可以通过多级冗余来解决该问题，就是一个媒体包不止做一次冗余，如下图，一个包在横竖两个方向做了冗余。

![](https://github.com/mo4772/mo4772.github.io/raw/master/pic/fec/fec_2.jpg)



哪几个包组合生成冗余数据，取决于策略需求。比如可以三个包产生一个冗余包；也可以三个包产生两个冗余包，前两个包生成一个冗余包，三个包一起生成一个冗余包，这种方式称做多级冗余。



在webrtc中也会使用这种多级冗余。



## fec的流程
### 一个通俗的例子
这里用做菜来打个比方，说明fec的核心流程。

假设中央厨房要做3道菜（原始包），送到各个食堂，同时也准备2道"混合菜"（FEC包）当备份：

| 菜品 | 原料组合配方 |
| --- | --- |
| **菜1** | 只含菜1 → `[1, 0, 0]` |
| **菜2** | 只含菜2 → `[0, 1, 0]` |
| **菜3** | 只含菜3 → `[0, 0, 1]` |
| **混合菜A** | 菜1+菜2 → `[1, 1, 0]` |
| **混合菜B** | 菜2+菜3 → `[0, 1, 1]` |




发送端 (中央大厨房)

1. 做菜：
    - 菜1、菜2、菜3
    - 混合菜A（菜1⊕菜2）
    - 混合菜B（菜2⊕菜3）
2. 打包送出：`[菜1, 菜2, 菜3, 混合菜A, 混合菜B]`和`[混合菜A，混合菜B的配方]`

接收端（食堂）

+ 场景1：丢菜2，但有其他所有菜  
**恢复：根据混合菜A的配方(混合菜A = 菜1⊕菜2)来恢复菜2，那么 菜2 = 混合菜A⊕菜1**
+ 场景2：丢菜1和菜3，只有菜2+混合菜A，B  
**恢复：根据混合菜A(混合菜A = 菜1⊕菜2)，混合菜B(混合菜B = 菜2⊕菜3)的配方来恢复菜1和菜3**
    1. **菜1 = 混合菜A⊕菜2**
    2. **菜3 = 混合菜B⊕菜2**

### 处理流程
上面的例子涉及到了fec的核心流程：

1. 确定fec包的个数，上面的例子是三个菜，产生了两个混合菜。
2. 确定如何生成fec包(用异或还是其他算法)，上面的例子选用了异或
3. 原始包，fec包及 **生成fec包的规则(哪几个原始包生成fec包)** 发送给对端，上面的例子中混合菜的规则就是配方。
4. 接收方**根据生成fec包的规则按**需来恢复原始包。



这也是webrtc中fec的核心流程。

